#!/bin/bash
#
# CARINA CLI
# Command-line interface for CARINA OS
#

set -e

CARINA_VERSION="0.3"
PROFILES_DIR="/opt/carina/profiles"
CONFIG_DIR="/etc/carina"
SANDBOX_DIR="/opt/carina/sandbox"
MISSIONLAB_DIR="/opt/carina/missionlab"

# CARINA Color Palette (from branding/colors.md)
# No pure black. No pure white. Everything lives in "space light" range.
CARINA_CYAN='\033[38;2;61;232;255m'      # #3DE8FF - action/active/success
CARINA_MAGENTA='\033[38;2;177;76;255m'   # #B14CFF - energy/alert/error
CARINA_BLUE='\033[38;2;31;162;255m'      # #1FA2FF - navigation/warning
CARINA_TEXT='\033[38;2;230;236;255m'     # #E6ECFF - primary text
CARINA_MUTED='\033[38;2;154;163;199m'    # #9AA3C7 - muted text
NC='\033[0m'

print_pass() {
    echo -e "[${CARINA_CYAN}PASS${NC}] $1"
}

print_warn() {
    echo -e "[${CARINA_BLUE}WARN${NC}] $1"
}

print_fail() {
    echo -e "[${CARINA_MAGENTA}FAIL${NC}] $1"
}

cmd_version() {
    echo -e "${CARINA_CYAN}CARINA OS${NC} version ${CARINA_TEXT}$CARINA_VERSION${NC}"
}

cmd_doctor() {
    echo -e "${CARINA_CYAN}CARINA Doctor${NC} - System Health Check"
    echo -e "${CARINA_MUTED}====================================${NC}"
    echo ""
    
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        if [[ "$ID" == "carina" ]]; then
            print_pass "OS: $PRETTY_NAME"
        elif [[ "$ID" == "ubuntu" ]]; then
            print_warn "OS: $PRETTY_NAME (not yet converted to CARINA)"
        else
            print_fail "OS: $PRETTY_NAME (unsupported)"
        fi
    else
        print_fail "OS: Cannot determine"
    fi
    
    local disk_usage
    disk_usage=$(df -h / | awk 'NR==2 {print $5}' | tr -d '%')
    if [[ $disk_usage -lt 80 ]]; then
        print_pass "Disk: ${disk_usage}% used"
    elif [[ $disk_usage -lt 90 ]]; then
        print_warn "Disk: ${disk_usage}% used"
    else
        print_fail "Disk: ${disk_usage}% used (critical)"
    fi
    
    local mem_total mem_avail mem_percent
    mem_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    mem_avail=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    mem_percent=$((100 - (mem_avail * 100 / mem_total)))
    if [[ $mem_percent -lt 80 ]]; then
        print_pass "Memory: ${mem_percent}% used"
    elif [[ $mem_percent -lt 90 ]]; then
        print_warn "Memory: ${mem_percent}% used"
    else
        print_fail "Memory: ${mem_percent}% used (critical)"
    fi
    
    if ping -c 1 -W 2 8.8.8.8 &>/dev/null; then
        print_pass "Network: Connected"
    else
        print_fail "Network: No connectivity"
    fi
    
    if systemctl is-system-running &>/dev/null; then
        local state
        state=$(systemctl is-system-running 2>/dev/null || echo "unknown")
        if [[ "$state" == "running" ]] || [[ "$state" == "degraded" ]]; then
            print_pass "Systemd: $state"
        else
            print_warn "Systemd: $state"
        fi
    else
        print_fail "Systemd: Not available"
    fi
    
    if command -v podman &>/dev/null; then
        print_pass "Container Runtime: Podman available"
    elif command -v docker &>/dev/null; then
        if docker info &>/dev/null; then
            print_warn "Container Runtime: Docker available (Podman preferred)"
        else
            print_warn "Container Runtime: Docker installed but not running"
        fi
    else
        print_warn "Container Runtime: Not installed (required for sandbox)"
    fi
    
    echo ""
    echo "Doctor check complete."
}

cmd_profile_list() {
    echo -e "${CARINA_CYAN}Available Profiles${NC}"
    echo -e "${CARINA_MUTED}==================${NC}"
    echo ""
    
    if [[ ! -d "$PROFILES_DIR" ]]; then
        echo "No profiles directory found at $PROFILES_DIR"
        echo "Run bootstrap script first."
        return 1
    fi
    
    for profile in "$PROFILES_DIR"/*/; do
        if [[ -d "$profile" ]]; then
            local name
            name=$(basename "$profile")
            local desc=""
            case "$name" in
                core)
                    desc="Minimal server profile with essential tools"
                    ;;
                flightdeck)
                    desc="GUI-enabled profile with desktop environment"
                    ;;
                missionlab-embedded)
                    desc="Embedded development toolchain (Arduino, PlatformIO)"
                    ;;
                missionlab-robotics)
                    desc="Robotics development tools (ROS2 tooling)"
                    ;;
                *)
                    desc="Custom profile"
                    ;;
            esac
            echo -e "  ${CARINA_CYAN}$name${NC} - $desc"
        fi
    done
}

cmd_profile_apply() {
    local profile_name="$1"
    
    if [[ -z "$profile_name" ]]; then
        echo "Usage: carina profile apply <name>"
        echo ""
        echo "Available profiles:"
        cmd_profile_list
        return 1
    fi
    
    local profile_dir="$PROFILES_DIR/$profile_name"
    
    if [[ ! -d "$profile_dir" ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Profile '$profile_name' not found"
        return 1
    fi
    
    echo -e "Applying profile: ${CARINA_CYAN}$profile_name${NC}"
    echo -e "${CARINA_MUTED}================================${NC}"
    
    if [[ -f "$profile_dir/packages.txt" ]]; then
        echo "Installing packages..."
        apt-get update -qq
        while IFS= read -r package || [[ -n "$package" ]]; do
            package=$(echo "$package" | tr -d '[:space:]')
            if [[ -n "$package" ]] && [[ ! "$package" =~ ^# ]]; then
                echo "  Installing: $package"
                apt-get install -y -qq "$package" || echo "  Warning: Failed to install $package"
            fi
        done < "$profile_dir/packages.txt"
        echo "Packages installed."
    fi
    
    if [[ -f "$profile_dir/config.sh" ]]; then
        echo "Running configuration..."
        bash "$profile_dir/config.sh"
        echo "Configuration complete."
    fi
    
    echo ""
    echo -e "Profile '${CARINA_CYAN}$profile_name${NC}' applied successfully."
}

cmd_gui_enable() {
    echo "Enabling GUI..."
    
    if [[ $EUID -ne 0 ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: This command requires root privileges (use sudo)"
        return 1
    fi
    
    if [[ -d "$PROFILES_DIR/flightdeck" ]]; then
        cmd_profile_apply flightdeck
    else
        echo "Installing GUI packages..."
        apt-get update -qq
        apt-get install -y -qq ubuntu-desktop-minimal gdm3 xrdp
    fi
    
    echo "Setting graphical target..."
    systemctl set-default graphical.target
    
    echo "Enabling display manager..."
    systemctl enable gdm3 2>/dev/null || true
    
    echo ""
    echo -e "${CARINA_CYAN}GUI enabled.${NC} Reboot to start graphical interface."
    echo "Run: sudo reboot"
}

cmd_gui_disable() {
    echo "Disabling GUI..."
    
    if [[ $EUID -ne 0 ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: This command requires root privileges (use sudo)"
        return 1
    fi
    
    echo "Setting multi-user target..."
    systemctl set-default multi-user.target
    
    echo "Stopping display manager..."
    systemctl stop gdm3 2>/dev/null || true
    systemctl disable gdm3 2>/dev/null || true
    
    echo ""
    echo -e "${CARINA_CYAN}GUI disabled.${NC} Reboot to apply changes."
    echo "Run: sudo reboot"
}

# ============================================================================
# SANDBOX COMMANDS
# ============================================================================

SANDBOX_TEMPLATES_DIR="$SANDBOX_DIR/templates"
SANDBOX_STATE_FILE="/var/lib/carina/sandboxes.json"
SANDBOX_LOG_FILE="/var/log/carina/sandbox.log"
SANDBOX_IMAGE_PREFIX="carina-sandbox"

sandbox_log_action() {
    local action="$1"
    local details="$2"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local user="${SUDO_USER:-$USER}"
    mkdir -p /var/log 2>/dev/null || true
    echo "[$timestamp] [$user] $action: $details" >> "$SANDBOX_LOG_FILE" 2>/dev/null || true
}

sandbox_ensure_dirs() {
    mkdir -p /var/lib/carina 2>/dev/null || true
    mkdir -p /var/log/carina 2>/dev/null || true
    touch "$SANDBOX_LOG_FILE" 2>/dev/null || true
    if [[ ! -f "$SANDBOX_STATE_FILE" ]]; then
        echo '{"sandboxes":[]}' > "$SANDBOX_STATE_FILE" 2>/dev/null || true
    fi
}

sandbox_check_podman() {
    if ! command -v podman &>/dev/null; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Podman is not installed"
        echo "Install with: sudo apt-get install -y podman"
        return 1
    fi
}

sandbox_generate_id() {
    local template="$1"
    local suffix
    suffix=$(head -c 4 /dev/urandom | xxd -p)
    echo "${template}-${suffix}"
}

sandbox_parse_ttl() {
    local ttl="$1"
    local seconds=0
    
    if [[ "$ttl" =~ ^([0-9]+)m$ ]]; then
        seconds=$((${BASH_REMATCH[1]} * 60))
    elif [[ "$ttl" =~ ^([0-9]+)h$ ]]; then
        seconds=$((${BASH_REMATCH[1]} * 3600))
    elif [[ "$ttl" =~ ^([0-9]+)s$ ]]; then
        seconds=${BASH_REMATCH[1]}
    elif [[ "$ttl" =~ ^([0-9]+)$ ]]; then
        seconds=$((ttl * 60))
    else
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Invalid TTL format: $ttl (use: 10m, 1h, 300s)"
        return 1
    fi
    
    echo "$seconds"
}

sandbox_add_state() {
    local id="$1"
    local template="$2"
    local ttl_seconds="$3"
    local start_time
    start_time=$(date +%s)
    local expire_time=$((start_time + ttl_seconds))
    
    sandbox_ensure_dirs
    
    local tmp_file
    tmp_file=$(mktemp)
    jq --arg id "$id" \
       --arg template "$template" \
       --argjson start "$start_time" \
       --argjson ttl "$ttl_seconds" \
       --argjson expire "$expire_time" \
       '.sandboxes += [{"id": $id, "template": $template, "start_time": $start, "ttl": $ttl, "expire_time": $expire}]' \
       "$SANDBOX_STATE_FILE" > "$tmp_file" 2>/dev/null
    mv "$tmp_file" "$SANDBOX_STATE_FILE" 2>/dev/null || true
}

sandbox_remove_state() {
    local id="$1"
    sandbox_ensure_dirs
    local tmp_file
    tmp_file=$(mktemp)
    jq --arg id "$id" '.sandboxes = [.sandboxes[] | select(.id != $id)]' "$SANDBOX_STATE_FILE" > "$tmp_file" 2>/dev/null
    mv "$tmp_file" "$SANDBOX_STATE_FILE" 2>/dev/null || true
}

cmd_sandbox_templates() {
    echo -e "${CARINA_CYAN}Available CARINA Sandbox Templates${NC}"
    echo -e "${CARINA_MUTED}===================================${NC}"
    echo ""
    
    if [[ ! -d "$SANDBOX_TEMPLATES_DIR" ]]; then
        echo "No templates directory found at $SANDBOX_TEMPLATES_DIR"
        echo "Run bootstrap script or install sandbox module first."
        return 1
    fi
    
    for template_dir in "$SANDBOX_TEMPLATES_DIR"/*/; do
        if [[ -d "$template_dir" ]] && [[ -f "$template_dir/Containerfile" ]]; then
            local name
            name=$(basename "$template_dir")
            echo -e "  ${CARINA_CYAN}-${NC} $name"
        fi
    done
}

cmd_sandbox_list() {
    echo -e "${CARINA_CYAN}Active CARINA Sandboxes${NC}"
    echo -e "${CARINA_MUTED}=======================${NC}"
    echo ""
    
    sandbox_ensure_dirs
    
    local current_time
    current_time=$(date +%s)
    
    if [[ ! -f "$SANDBOX_STATE_FILE" ]]; then
        echo "No active sandboxes"
        return 0
    fi
    
    local count
    count=$(jq '.sandboxes | length' "$SANDBOX_STATE_FILE" 2>/dev/null || echo "0")
    
    if [[ "$count" -eq 0 ]]; then
        echo "No active sandboxes"
        return 0
    fi
    
    printf "%-14s %-10s %-8s %-8s\n" "ID" "TEMPLATE" "AGE" "TTL"
    printf "%-14s %-10s %-8s %-8s\n" "--" "--------" "---" "---"
    
    jq -r '.sandboxes[] | "\(.id)|\(.template)|\(.start_time)|\(.expire_time)"' "$SANDBOX_STATE_FILE" 2>/dev/null | while IFS='|' read -r id template start_time expire_time; do
        local age=$((current_time - start_time))
        local ttl_remaining=$((expire_time - current_time))
        
        local age_str
        if [[ $age -lt 60 ]]; then
            age_str="${age}s"
        else
            age_str="$((age / 60))m"
        fi
        
        local ttl_str
        if [[ $ttl_remaining -le 0 ]]; then
            ttl_str="expired"
        elif [[ $ttl_remaining -lt 60 ]]; then
            ttl_str="${ttl_remaining}s"
        else
            ttl_str="$((ttl_remaining / 60))m"
        fi
        
        printf "%-14s %-10s %-8s %-8s\n" "$id" "$template" "$age_str" "$ttl_str"
    done
}

cmd_sandbox_up() {
    local template=""
    local ttl="10m"
    local name=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --ttl)
                ttl="$2"
                shift 2
                ;;
            --name)
                name="$2"
                shift 2
                ;;
            -*)
                echo -e "${CARINA_MAGENTA}ERROR${NC}: Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$template" ]]; then
                    template="$1"
                fi
                shift
                ;;
        esac
    done
    
    sandbox_check_podman || return 1
    sandbox_ensure_dirs
    
    if [[ -z "$template" ]]; then
        echo "Usage: carina sandbox up <template> [--ttl 10m] [--name <name>]"
        echo ""
        cmd_sandbox_templates
        return 1
    fi
    
    local template_dir="$SANDBOX_TEMPLATES_DIR/$template"
    if [[ ! -d "$template_dir" ]] || [[ ! -f "$template_dir/Containerfile" ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Template '$template' not found"
        echo ""
        cmd_sandbox_templates
        return 1
    fi
    
    local ttl_seconds
    ttl_seconds=$(sandbox_parse_ttl "$ttl") || return 1
    
    local sandbox_id
    if [[ -n "$name" ]]; then
        sandbox_id="$name"
    else
        sandbox_id=$(sandbox_generate_id "$template")
    fi
    
    local image_name="${SANDBOX_IMAGE_PREFIX}-${template}:latest"
    
    echo -e "Building sandbox image: ${CARINA_CYAN}$template${NC}"
    sandbox_log_action "BUILD" "template=$template image=$image_name"
    
    podman build -t "$image_name" -f "$template_dir/Containerfile" "$template_dir" >/dev/null 2>&1
    
    echo -e "Starting sandbox: ${CARINA_CYAN}$sandbox_id${NC}"
    sandbox_log_action "START" "id=$sandbox_id template=$template ttl=${ttl_seconds}s"
    
    podman run -d \
        --name "$sandbox_id" \
        --security-opt no-new-privileges:true \
        --cap-drop ALL \
        --read-only \
        --tmpfs /tmp:rw,noexec,nosuid,size=100m \
        --tmpfs /home/sandbox:rw,noexec,nosuid,size=100m \
        --network bridge \
        --memory 512m \
        --cpus 1 \
        "$image_name" \
        sleep infinity >/dev/null
    
    sandbox_add_state "$sandbox_id" "$template" "$ttl_seconds"
    
    local ttl_display
    if [[ $ttl_seconds -lt 60 ]]; then
        ttl_display="${ttl_seconds} seconds"
    else
        ttl_display="$((ttl_seconds / 60)) minutes"
    fi
    
    echo ""
    echo -e "${CARINA_CYAN}Sandbox started:${NC} $sandbox_id"
    echo -e "${CARINA_TEXT}TTL:${NC} $ttl_display"
}

cmd_sandbox_exec() {
    local sandbox_id="$1"
    shift || true
    local cmd=("$@")
    
    sandbox_check_podman || return 1
    
    if [[ -z "$sandbox_id" ]]; then
        echo "Usage: carina sandbox exec <name|id> <command>"
        return 1
    fi
    
    if [[ ${#cmd[@]} -eq 0 ]]; then
        cmd=("bash")
    fi
    
    if ! podman container exists "$sandbox_id" 2>/dev/null; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Sandbox '$sandbox_id' not found"
        return 1
    fi
    
    sandbox_log_action "EXEC" "id=$sandbox_id cmd=${cmd[*]}"
    
    podman exec -it "$sandbox_id" "${cmd[@]}"
}

cmd_sandbox_down() {
    local sandbox_id="$1"
    
    sandbox_check_podman || return 1
    sandbox_ensure_dirs
    
    if [[ -z "$sandbox_id" ]]; then
        echo "Usage: carina sandbox down <name|id>"
        return 1
    fi
    
    echo -e "Stopping sandbox: ${CARINA_CYAN}$sandbox_id${NC}"
    sandbox_log_action "STOP" "id=$sandbox_id"
    
    podman stop "$sandbox_id" >/dev/null 2>&1 || true
    podman rm -f "$sandbox_id" >/dev/null 2>&1 || true
    
    sandbox_remove_state "$sandbox_id"
    
    echo -e "${CARINA_CYAN}Sandbox destroyed:${NC} $sandbox_id"
}

cmd_sandbox_cleanup() {
    sandbox_check_podman || return 1
    sandbox_ensure_dirs
    
    echo -e "${CARINA_CYAN}CARINA Sandbox Cleanup${NC}"
    echo -e "${CARINA_MUTED}======================${NC}"
    echo ""
    
    local current_time
    current_time=$(date +%s)
    
    # Remove expired sandboxes (TTL exceeded)
    if [[ -f "$SANDBOX_STATE_FILE" ]]; then
        jq -r '.sandboxes[] | "\(.id)|\(.expire_time)"' "$SANDBOX_STATE_FILE" 2>/dev/null | while IFS='|' read -r id expire_time; do
            if [[ $current_time -ge $expire_time ]]; then
                echo -e "Removing expired sandbox: ${CARINA_MAGENTA}$id${NC}"
                sandbox_log_action "CLEANUP" "id=$id reason=expired"
                podman stop "$id" >/dev/null 2>&1 || true
                podman rm -f "$id" >/dev/null 2>&1 || true
                sandbox_remove_state "$id"
            fi
        done
    fi
    
    echo ""
    echo "Checking for orphaned containers..."
    local orphans
    orphans=$(podman ps -a --filter "name=${SANDBOX_IMAGE_PREFIX}" --format "{{.Names}}" 2>/dev/null || true)
    
    # Remove containers that exist but aren't in state file
    for container in $orphans; do
        if [[ -f "$SANDBOX_STATE_FILE" ]]; then
            if ! jq -e --arg id "$container" '.sandboxes[] | select(.id == $id)' "$SANDBOX_STATE_FILE" >/dev/null 2>&1; then
                echo -e "Removing orphan container: ${CARINA_MAGENTA}$container${NC}"
                sandbox_log_action "CLEANUP" "id=$container reason=orphan_container"
                podman rm -f "$container" >/dev/null 2>&1 || true
            fi
        fi
    done
    
    # Remove state entries where container no longer exists
    echo "Checking for orphaned state entries..."
    if [[ -f "$SANDBOX_STATE_FILE" ]]; then
        jq -r '.sandboxes[].id' "$SANDBOX_STATE_FILE" 2>/dev/null | while read -r id; do
            if ! podman container exists "$id" 2>/dev/null; then
                echo -e "Removing orphan state: ${CARINA_MAGENTA}$id${NC}"
                sandbox_log_action "CLEANUP" "id=$id reason=orphan_state"
                sandbox_remove_state "$id"
            fi
        done
    fi
    
    echo ""
    echo -e "${CARINA_CYAN}Cleanup complete${NC}"
}

cmd_sandbox_help() {
    echo -e "${CARINA_CYAN}CARINA Sandbox${NC} - Mission-Safe Execution Environments"
    echo ""
    echo -e "${CARINA_TEXT}Usage:${NC} carina sandbox <command> [options]"
    echo ""
    echo -e "${CARINA_TEXT}Commands:${NC}"
    echo -e "  ${CARINA_CYAN}templates${NC}           List available sandbox templates"
    echo -e "  ${CARINA_CYAN}list${NC}                List active sandboxes"
    echo -e "  ${CARINA_CYAN}up${NC} <template>       Start a new sandbox"
    echo -e "  ${CARINA_CYAN}exec${NC} <id> <cmd>     Execute command in sandbox"
    echo -e "  ${CARINA_CYAN}down${NC} <id>           Stop and remove sandbox"
    echo -e "  ${CARINA_CYAN}cleanup${NC}             Remove expired/orphaned sandboxes"
    echo ""
    echo -e "${CARINA_TEXT}Options for 'up':${NC}"
    echo "  --ttl <duration>    Time to live (default: 10m)"
    echo "  --name <name>       Custom sandbox name"
    echo ""
    echo -e "${CARINA_TEXT}Examples:${NC}"
    echo "  carina sandbox up python --ttl 30m"
    echo "  carina sandbox exec python-abc123 python --version"
    echo "  carina sandbox down python-abc123"
    echo ""
}

# ============================================================================
# MISSIONLAB COMMANDS
# ============================================================================

MISSIONLAB_PROFILES_DIR="$MISSIONLAB_DIR/profiles"

cmd_missionlab_status() {
    echo -e "${CARINA_CYAN}CARINA MissionLab Status${NC}"
    echo -e "${CARINA_MUTED}========================${NC}"
    echo ""
    
    local user="${SUDO_USER:-$USER}"
    
    # Check toolchain availability
    echo -e "${CARINA_TEXT}Toolchain:${NC}"
    
    if command -v arduino-cli &>/dev/null; then
        local version=$(arduino-cli version 2>/dev/null | head -1 || echo "unknown")
        print_pass "arduino-cli: $version"
    else
        print_warn "arduino-cli: Not installed"
    fi
    
    if command -v platformio &>/dev/null || python3 -c "import platformio" 2>/dev/null; then
        print_pass "PlatformIO: Available"
    else
        print_warn "PlatformIO: Not installed"
    fi
    
    if command -v avrdude &>/dev/null; then
        print_pass "avrdude: Available"
    else
        print_warn "avrdude: Not installed"
    fi
    
    if command -v openocd &>/dev/null; then
        print_pass "OpenOCD: Available"
    else
        print_warn "OpenOCD: Not installed"
    fi
    
    if command -v minicom &>/dev/null; then
        print_pass "minicom: Available"
    else
        print_warn "minicom: Not installed"
    fi
    
    echo ""
    echo -e "${CARINA_TEXT}User Groups:${NC}"
    
    if groups "$user" 2>/dev/null | grep -q '\bdialout\b'; then
        print_pass "$user is in dialout group (serial access)"
    else
        print_fail "$user is NOT in dialout group"
        echo "      Run: sudo usermod -aG dialout $user"
    fi
    
    if groups "$user" 2>/dev/null | grep -q '\bplugdev\b'; then
        print_pass "$user is in plugdev group (USB access)"
    else
        print_fail "$user is NOT in plugdev group"
        echo "      Run: sudo usermod -aG plugdev $user"
    fi
    
    echo ""
    echo -e "${CARINA_TEXT}Serial Access:${NC}"
    
    local serial_ok=1
    for port in /dev/ttyUSB* /dev/ttyACM*; do
        if [[ -e "$port" ]]; then
            if [[ -r "$port" ]] && [[ -w "$port" ]]; then
                print_pass "$port: Accessible"
            else
                print_fail "$port: Permission denied"
                serial_ok=0
            fi
        fi
    done
    
    if [[ $serial_ok -eq 1 ]]; then
        local count=$(ls /dev/ttyUSB* /dev/ttyACM* 2>/dev/null | wc -l)
        if [[ $count -eq 0 ]]; then
            echo -e "  ${CARINA_MUTED}No serial devices currently connected${NC}"
        fi
    fi
    
    echo ""
    echo -e "${CARINA_TEXT}udev Rules:${NC}"
    
    if [[ -f /etc/udev/rules.d/99-carina-serial.rules ]]; then
        print_pass "Serial rules installed"
    else
        print_warn "Serial rules not installed"
    fi
    
    if [[ -f /etc/udev/rules.d/99-carina-usb.rules ]]; then
        print_pass "USB rules installed"
    else
        print_warn "USB rules not installed"
    fi
    
    echo ""
}

cmd_missionlab_devices() {
    local device_detect="$MISSIONLAB_DIR/device-detect.sh"
    
    if [[ -x "$device_detect" ]]; then
        bash "$device_detect"
    else
        echo -e "${CARINA_CYAN}CARINA MissionLab - Device Detection${NC}"
        echo -e "${CARINA_MUTED}=====================================${NC}"
        echo ""
        
        echo -e "${CARINA_TEXT}Serial Ports:${NC}"
        local found=0
        for port in /dev/ttyUSB* /dev/ttyACM*; do
            if [[ -e "$port" ]]; then
                found=1
                echo -e "  ${CARINA_CYAN}$port${NC}"
            fi
        done
        if [[ $found -eq 0 ]]; then
            echo -e "  ${CARINA_MUTED}No serial ports detected${NC}"
        fi
        
        echo ""
        echo -e "${CARINA_TEXT}USB Devices:${NC}"
        if command -v lsusb &>/dev/null; then
            lsusb 2>/dev/null | head -10
        else
            echo -e "  ${CARINA_MUTED}lsusb not available${NC}"
        fi
    fi
}

cmd_missionlab_help() {
    echo -e "${CARINA_CYAN}CARINA MissionLab${NC} - Embedded & Robotics Development"
    echo ""
    echo -e "${CARINA_TEXT}Usage:${NC} carina missionlab <command>"
    echo ""
    echo -e "${CARINA_TEXT}Commands:${NC}"
    echo -e "  ${CARINA_CYAN}status${NC}              Check toolchain and device access"
    echo -e "  ${CARINA_CYAN}devices${NC}             Detect connected devices"
    echo ""
    echo -e "${CARINA_TEXT}Profiles:${NC}"
    echo "  carina profile apply missionlab-embedded"
    echo "  carina profile apply missionlab-robotics"
    echo ""
}

# ============================================================================
# CONTROL COMMANDS (Sprint 5A - Confirm-to-Execute Mode)
# ============================================================================

CONTROL_DIR="/opt/carina/control"
CONTROL_PROPOSALS_FILE="/var/lib/carina/control/proposals.json"
CONTROL_LOG_FILE="/var/log/carina-control.log"

control_ensure_dirs() {
    mkdir -p /var/lib/carina/control 2>/dev/null || true
    if [[ ! -f "$CONTROL_PROPOSALS_FILE" ]]; then
        echo '{"proposals":[],"next_id":1}' > "$CONTROL_PROPOSALS_FILE" 2>/dev/null || true
    fi
    chmod 664 "$CONTROL_PROPOSALS_FILE" 2>/dev/null || true
}

control_log_action() {
    local user="${SUDO_USER:-$(whoami)}"
    local action="$1"
    local proposal_id="$2"
    local status="$3"
    local sandbox="${4:-none}"
    local extra="${5:-}"
    
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local log_entry="$timestamp user=$user action=$action proposal=$proposal_id status=$status sandbox=$sandbox"
    
    if [[ -n "$extra" ]]; then
        log_entry="$log_entry $extra"
    fi
    
    echo "$log_entry" >> "$CONTROL_LOG_FILE" 2>/dev/null || true
}

# Policy validation - whitelist approach for safety
control_validate_command() {
    local cmd="$1"
    
    # Forbidden patterns (blacklist)
    local forbidden_patterns=(
        "rm -rf /"
        "sudo "
        "su "
        "systemctl "
        "service "
        "chmod 777"
        "chown root"
        "nmap "
        "apt install"
        "apt-get install"
        "pip install"
        "eval "
        "exec "
        "/etc/shadow"
        "/etc/passwd"
        ".ssh/"
        ".env"
    )
    
    for pattern in "${forbidden_patterns[@]}"; do
        if [[ "$cmd" == *"$pattern"* ]]; then
            echo "FORBIDDEN"
            return 1
        fi
    done
    
    # Allowed patterns (whitelist)
    local allowed_patterns=(
        "^[a-zA-Z0-9_-]+ --version$"
        "^[a-zA-Z0-9_-]+ -v$"
        "^[a-zA-Z0-9_-]+ version$"
        "^arduino-cli "
        "^platformio "
        "^python --version$"
        "^python3 --version$"
        "^node --version$"
        "^npm --version$"
        "^cargo --version$"
        "^rustc --version$"
        "^go version$"
        "^gcc --version$"
        "^make --version$"
        "^uname "
        "^cat /etc/os-release$"
        "^df -h$"
        "^free -h$"
        "^uptime$"
        "^whoami$"
        "^id$"
        "^ls "
        "^make$"
        "^make test$"
        "^npm test$"
        "^npm run "
        "^cargo test$"
        "^cargo build$"
        "^pytest$"
    )
    
    for pattern in "${allowed_patterns[@]}"; do
        if [[ "$cmd" =~ $pattern ]]; then
            echo "ALLOWED"
            return 0
        fi
    done
    
    echo "NOT_ALLOWED"
    return 1
}

control_assess_risk() {
    local cmd="$1"
    
    if [[ "$cmd" =~ (--version|-v|version|whoami|id|uname|uptime) ]]; then
        echo "low"
    elif [[ "$cmd" =~ (cat|ls|head|tail|make|build|test) ]]; then
        echo "medium"
    else
        echo "medium"
    fi
}

cmd_control_propose() {
    local description="$1"
    local command="$2"
    local template="${3:-ubuntu}"
    
    if [[ -z "$description" ]] || [[ -z "$command" ]]; then
        echo -e "${CARINA_CYAN}CARINA Control${NC} - Propose Action"
        echo ""
        echo "Usage: carina control propose <description> <command> [template]"
        echo ""
        echo "Example:"
        echo "  carina control propose \"Check Arduino CLI version\" \"arduino-cli version\" ubuntu"
        return 1
    fi
    
    control_ensure_dirs
    
    # Validate command against policy
    local policy_result
    policy_result=$(control_validate_command "$command")
    
    if [[ "$policy_result" == "FORBIDDEN" ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Command rejected by policy engine (forbidden pattern)"
        control_log_action "propose" "0" "rejected" "$template" "reason=forbidden"
        return 1
    fi
    
    if [[ "$policy_result" == "NOT_ALLOWED" ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Command not in allowed whitelist"
        echo "Only safe, read-only commands are permitted."
        control_log_action "propose" "0" "rejected" "$template" "reason=not_allowed"
        return 1
    fi
    
    # Get next ID
    local id
    id=$(jq -r '.next_id' "$CONTROL_PROPOSALS_FILE" 2>/dev/null || echo "1")
    
    # Assess risk
    local risk_level
    risk_level=$(control_assess_risk "$command")
    
    # Create proposal
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    local tmp_file
    tmp_file=$(mktemp)
    
    jq --argjson id "$id" \
       --arg desc "$description" \
       --arg cmd "$command" \
       --arg template "$template" \
       --arg risk "$risk_level" \
       --arg ts "$timestamp" \
       '.proposals += [{
           id: $id,
           description: $desc,
           command: $cmd,
           sandbox_template: $template,
           risk_level: $risk,
           status: "pending",
           created_at: $ts
       }] | .next_id = ($id + 1)' \
       "$CONTROL_PROPOSALS_FILE" > "$tmp_file" 2>/dev/null
    
    mv "$tmp_file" "$CONTROL_PROPOSALS_FILE"
    chmod 664 "$CONTROL_PROPOSALS_FILE" 2>/dev/null || true
    
    control_log_action "propose" "$id" "created" "$template"
    
    echo -e "${CARINA_CYAN}Proposal created:${NC}"
    echo ""
    echo -e "  [$id] $description"
    echo -e "       Command: $command"
    echo -e "       Risk: ${risk_level^^}"
    echo -e "       Sandbox: $template"
    echo ""
    echo -e "Use: ${CARINA_CYAN}carina control approve $id${NC}"
}

cmd_control_list() {
    local status_filter="${1:-all}"
    
    control_ensure_dirs
    
    echo -e "${CARINA_CYAN}CARINA Control${NC} - Proposed Actions"
    echo -e "${CARINA_MUTED}=================================${NC}"
    echo ""
    
    local count
    count=$(jq '.proposals | length' "$CONTROL_PROPOSALS_FILE" 2>/dev/null || echo "0")
    
    if [[ "$count" -eq 0 ]]; then
        echo "No proposals"
        return 0
    fi
    
    if [[ "$status_filter" == "all" ]]; then
        jq -r '.proposals[] | "[\(.id)] \(.description)\n     Command: \(.command)\n     Risk: \(.risk_level | ascii_upcase)\n     Sandbox: \(.sandbox_template)\n     Status: \(.status)\n"' "$CONTROL_PROPOSALS_FILE" 2>/dev/null
    else
        jq -r --arg status "$status_filter" '.proposals[] | select(.status == $status) | "[\(.id)] \(.description)\n     Command: \(.command)\n     Risk: \(.risk_level | ascii_upcase)\n     Sandbox: \(.sandbox_template)\n     Status: \(.status)\n"' "$CONTROL_PROPOSALS_FILE" 2>/dev/null
    fi
    
    echo ""
    echo -e "Use: ${CARINA_CYAN}carina control approve <id>${NC}"
}

cmd_control_approve() {
    local id="$1"
    
    if [[ -z "$id" ]]; then
        echo "Usage: carina control approve <id>"
        return 1
    fi
    
    control_ensure_dirs
    
    # Get proposal
    local proposal
    proposal=$(jq -r --argjson id "$id" '.proposals[] | select(.id == $id)' "$CONTROL_PROPOSALS_FILE" 2>/dev/null)
    
    if [[ -z "$proposal" ]] || [[ "$proposal" == "null" ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Proposal $id not found"
        control_log_action "approve" "$id" "not_found"
        return 1
    fi
    
    # Check status
    local status
    status=$(echo "$proposal" | jq -r '.status')
    if [[ "$status" != "pending" ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Proposal $id is not pending (status: $status)"
        control_log_action "approve" "$id" "invalid_status"
        return 1
    fi
    
    # Extract details
    local command template description
    command=$(echo "$proposal" | jq -r '.command')
    template=$(echo "$proposal" | jq -r '.sandbox_template')
    description=$(echo "$proposal" | jq -r '.description')
    
    # Re-validate command (defense in depth)
    local policy_result
    policy_result=$(control_validate_command "$command")
    
    if [[ "$policy_result" != "ALLOWED" ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Policy rejected on re-validation"
        
        # Update status to rejected
        local tmp_file
        tmp_file=$(mktemp)
        jq --argjson id "$id" '(.proposals[] | select(.id == $id)).status = "rejected"' "$CONTROL_PROPOSALS_FILE" > "$tmp_file"
        mv "$tmp_file" "$CONTROL_PROPOSALS_FILE"
        
        control_log_action "approve" "$id" "policy_rejected" "$template"
        return 1
    fi
    
    echo -e "Approving proposal $id: ${CARINA_CYAN}$description${NC}"
    echo ""
    
    # Update status to approved
    local tmp_file
    tmp_file=$(mktemp)
    jq --argjson id "$id" '(.proposals[] | select(.id == $id)).status = "approved"' "$CONTROL_PROPOSALS_FILE" > "$tmp_file"
    mv "$tmp_file" "$CONTROL_PROPOSALS_FILE"
    
    control_log_action "approve" "$id" "approved" "$template"
    
    # SECURITY: Execute ONLY via sandbox
    echo "Spawning sandbox..."
    
    # Create sandbox with TTL
    local sandbox_output
    sandbox_output=$(cmd_sandbox_up "$template" --ttl 5m 2>&1)
    
    # Extract sandbox name
    local sandbox_name
    sandbox_name=$(echo "$sandbox_output" | grep 'Sandbox started:' | awk '{print $3}' | head -1)
    
    if [[ -z "$sandbox_name" ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Failed to create sandbox"
        
        tmp_file=$(mktemp)
        jq --argjson id "$id" '(.proposals[] | select(.id == $id)).status = "failed"' "$CONTROL_PROPOSALS_FILE" > "$tmp_file"
        mv "$tmp_file" "$CONTROL_PROPOSALS_FILE"
        
        control_log_action "execute" "$id" "sandbox_failed" "$template"
        return 1
    fi
    
    echo "Executing command in sandbox $sandbox_name..."
    echo ""
    
    # Execute command inside sandbox
    local result exit_code
    result=$(cmd_sandbox_exec "$sandbox_name" $command 2>&1)
    exit_code=$?
    
    echo -e "${CARINA_TEXT}Result:${NC}"
    echo "$result"
    echo ""
    
    # Destroy sandbox
    echo "Destroying sandbox..."
    cmd_sandbox_down "$sandbox_name" --force 2>/dev/null || true
    
    # Update status
    if [[ $exit_code -eq 0 ]]; then
        tmp_file=$(mktemp)
        jq --argjson id "$id" '(.proposals[] | select(.id == $id)).status = "executed"' "$CONTROL_PROPOSALS_FILE" > "$tmp_file"
        mv "$tmp_file" "$CONTROL_PROPOSALS_FILE"
        
        control_log_action "execute" "$id" "success" "$template" "result=success"
        echo -e "${CARINA_CYAN}Sandbox destroyed.${NC}"
    else
        tmp_file=$(mktemp)
        jq --argjson id "$id" '(.proposals[] | select(.id == $id)).status = "failed"' "$CONTROL_PROPOSALS_FILE" > "$tmp_file"
        mv "$tmp_file" "$CONTROL_PROPOSALS_FILE"
        
        control_log_action "execute" "$id" "failed" "$template" "result=failed exit_code=$exit_code"
        echo "Sandbox destroyed. (command failed with exit code $exit_code)"
    fi
    
    return $exit_code
}

cmd_control_reject() {
    local id="$1"
    local reason="${2:-User rejected}"
    
    if [[ -z "$id" ]]; then
        echo "Usage: carina control reject <id> [reason]"
        return 1
    fi
    
    control_ensure_dirs
    
    # Get proposal
    local proposal
    proposal=$(jq -r --argjson id "$id" '.proposals[] | select(.id == $id)' "$CONTROL_PROPOSALS_FILE" 2>/dev/null)
    
    if [[ -z "$proposal" ]] || [[ "$proposal" == "null" ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Proposal $id not found"
        control_log_action "reject" "$id" "not_found"
        return 1
    fi
    
    # Check status
    local status
    status=$(echo "$proposal" | jq -r '.status')
    if [[ "$status" != "pending" ]]; then
        echo -e "${CARINA_MAGENTA}ERROR${NC}: Proposal $id is not pending (status: $status)"
        control_log_action "reject" "$id" "invalid_status"
        return 1
    fi
    
    # Update status
    local tmp_file
    tmp_file=$(mktemp)
    jq --argjson id "$id" '(.proposals[] | select(.id == $id)).status = "rejected"' "$CONTROL_PROPOSALS_FILE" > "$tmp_file"
    mv "$tmp_file" "$CONTROL_PROPOSALS_FILE"
    
    control_log_action "reject" "$id" "rejected"
    
    echo -e "Proposal $id rejected: $reason"
}

cmd_control_clear() {
    control_ensure_dirs
    
    local tmp_file
    tmp_file=$(mktemp)
    jq '.proposals = [.proposals[] | select(.status == "pending")]' "$CONTROL_PROPOSALS_FILE" > "$tmp_file"
    mv "$tmp_file" "$CONTROL_PROPOSALS_FILE"
    chmod 664 "$CONTROL_PROPOSALS_FILE" 2>/dev/null || true
    
    control_log_action "clear" "all" "cleared"
    
    echo "Cleared completed and rejected proposals"
}

cmd_control_help() {
    echo -e "${CARINA_CYAN}CARINA Control${NC} - AI Advisory & Execution"
    echo ""
    echo -e "${CARINA_TEXT}Usage:${NC} carina control <command>"
    echo ""
    echo -e "${CARINA_TEXT}Commands:${NC}"
    echo -e "  ${CARINA_CYAN}propose${NC} <desc> <cmd> [template]  Create a new proposal"
    echo -e "  ${CARINA_CYAN}list${NC} [status]                    List proposals"
    echo -e "  ${CARINA_CYAN}approve${NC} <id>                     Approve and execute proposal"
    echo -e "  ${CARINA_CYAN}reject${NC} <id> [reason]             Reject a proposal"
    echo -e "  ${CARINA_CYAN}clear${NC}                            Clear completed proposals"
    echo ""
    echo -e "${CARINA_TEXT}Security:${NC}"
    echo "  - All execution occurs inside sandboxes"
    echo "  - Commands are validated against policy whitelist"
    echo "  - No direct host modification allowed"
    echo "  - All actions are logged to /var/log/carina-control.log"
    echo ""
    echo -e "${CARINA_TEXT}Example:${NC}"
    echo "  carina control propose \"Check Arduino version\" \"arduino-cli version\""
    echo "  carina control approve 1"
    echo ""
}

# ============================================================================
# HELP
# ============================================================================

cmd_help() {
    echo -e "${CARINA_CYAN}CARINA CLI${NC} - Version ${CARINA_TEXT}$CARINA_VERSION${NC}"
    echo ""
    echo -e "${CARINA_TEXT}Usage:${NC} carina <command> [options]"
    echo ""
    echo -e "${CARINA_TEXT}Commands:${NC}"
    echo -e "  ${CARINA_CYAN}doctor${NC}              Check system health"
    echo -e "  ${CARINA_CYAN}profile${NC} <cmd>       Manage system profiles"
    echo -e "  ${CARINA_CYAN}gui${NC} <cmd>           Enable/disable graphical interface"
    echo -e "  ${CARINA_CYAN}sandbox${NC} <cmd>       Manage sandbox environments"
    echo -e "  ${CARINA_CYAN}missionlab${NC} <cmd>    Embedded & robotics development"
    echo -e "  ${CARINA_CYAN}control${NC} <cmd>       AI advisory & sandboxed execution"
    echo -e "  ${CARINA_CYAN}version${NC}             Show version"
    echo -e "  ${CARINA_CYAN}help${NC}                Show this help"
    echo ""
    echo -e "${CARINA_TEXT}Profile commands:${NC}"
    echo "  profile list        List available profiles"
    echo "  profile apply <n>   Apply a profile"
    echo ""
    echo -e "${CARINA_TEXT}GUI commands:${NC}"
    echo "  gui enable          Enable graphical interface"
    echo "  gui disable         Disable graphical interface"
    echo ""
    echo -e "${CARINA_TEXT}Sandbox commands:${NC}"
    echo "  sandbox templates   List sandbox templates"
    echo "  sandbox list        List active sandboxes"
    echo "  sandbox up <t>      Start a sandbox"
    echo "  sandbox exec <id>   Execute in sandbox"
    echo "  sandbox down <id>   Stop sandbox"
    echo "  sandbox cleanup     Remove expired sandboxes"
    echo ""
    echo -e "${CARINA_TEXT}MissionLab commands:${NC}"
    echo "  missionlab status   Check toolchain and access"
    echo "  missionlab devices  Detect connected devices"
    echo ""
    echo -e "${CARINA_TEXT}Control commands:${NC}"
    echo "  control propose     Create a new proposal"
    echo "  control list        List proposals"
    echo "  control approve     Approve and execute"
    echo "  control reject      Reject a proposal"
    echo "  control clear       Clear completed proposals"
    echo ""
}

main() {
    local cmd="${1:-help}"
    shift || true
    
    case "$cmd" in
        doctor)
            cmd_doctor
            ;;
        profile)
            local subcmd="${1:-list}"
            shift || true
            case "$subcmd" in
                list)
                    cmd_profile_list
                    ;;
                apply)
                    cmd_profile_apply "$@"
                    ;;
                *)
                    echo -e "${CARINA_MAGENTA}ERROR${NC}: Unknown profile command: $subcmd"
                    echo "Usage: carina profile [list|apply <name>]"
                    exit 1
                    ;;
            esac
            ;;
        gui)
            local subcmd="${1:-}"
            shift || true
            case "$subcmd" in
                enable)
                    cmd_gui_enable
                    ;;
                disable)
                    cmd_gui_disable
                    ;;
                *)
                    echo -e "${CARINA_MAGENTA}ERROR${NC}: Unknown gui command: $subcmd"
                    echo "Usage: carina gui [enable|disable]"
                    exit 1
                    ;;
            esac
            ;;
        sandbox)
            local subcmd="${1:-help}"
            shift || true
            case "$subcmd" in
                templates)
                    cmd_sandbox_templates
                    ;;
                list)
                    cmd_sandbox_list
                    ;;
                up)
                    cmd_sandbox_up "$@"
                    ;;
                exec)
                    cmd_sandbox_exec "$@"
                    ;;
                down)
                    cmd_sandbox_down "$@"
                    ;;
                cleanup)
                    cmd_sandbox_cleanup
                    ;;
                help|--help|-h)
                    cmd_sandbox_help
                    ;;
                *)
                    echo -e "${CARINA_MAGENTA}ERROR${NC}: Unknown sandbox command: $subcmd"
                    cmd_sandbox_help
                    exit 1
                    ;;
            esac
            ;;
        missionlab)
            local subcmd="${1:-help}"
            shift || true
            case "$subcmd" in
                status)
                    cmd_missionlab_status
                    ;;
                devices)
                    cmd_missionlab_devices
                    ;;
                help|--help|-h)
                    cmd_missionlab_help
                    ;;
                *)
                    echo -e "${CARINA_MAGENTA}ERROR${NC}: Unknown missionlab command: $subcmd"
                    cmd_missionlab_help
                    exit 1
                    ;;
            esac
            ;;
        control)
            local subcmd="${1:-help}"
            shift || true
            case "$subcmd" in
                propose)
                    cmd_control_propose "$@"
                    ;;
                list)
                    cmd_control_list "$@"
                    ;;
                approve)
                    cmd_control_approve "$@"
                    ;;
                reject)
                    cmd_control_reject "$@"
                    ;;
                clear)
                    cmd_control_clear
                    ;;
                help|--help|-h)
                    cmd_control_help
                    ;;
                *)
                    echo -e "${CARINA_MAGENTA}ERROR${NC}: Unknown control command: $subcmd"
                    cmd_control_help
                    exit 1
                    ;;
            esac
            ;;
        version)
            cmd_version
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            echo -e "${CARINA_MAGENTA}ERROR${NC}: Unknown command: $cmd"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
